import 'dart:convert';
import 'package:http/http.dart' as http;
import 'package:shared_preferences/shared_preferences.dart';
import 'package:ppe_mobile/services/api_service.dart';
class AuthService {
  static const String baseUrl = "${ApiService.baseUrl}/api/auth";
  static const String _tokenKey = 'jwt_token';
  static const String _userKey = 'user_data';

  // Connexion
  static Future<Map<String, dynamic>> login(
    String email,
    String motDePasse,
  ) async {
    try {
      print(' Tentative de connexion pour: $email');
      print(' URL: $baseUrl/login');

      final response = await http.post(
        Uri.parse('$baseUrl/login'),
        headers: {'Content-Type': 'application/json; charset=UTF-8'},
        body: jsonEncode({'email': email, 'motDePasse': motDePasse}),
      );

      print(' Status Code: ${response.statusCode}');
      print(' Response Body: ${response.body}');
      print(' Response Headers: ${response.headers}');

      if (response.statusCode == 200) {
        // V√©rifier si la r√©ponse est vide
        if (response.body.isEmpty) {
          print(' R√©ponse vide du serveur');
          return {
            'success': false,
            'message':
                'R√©ponse vide du serveur. V√©rifiez la configuration de l\'API.',
          };
        }

        try {
          final jsonResponse = json.decode(response.body);
          print(' JSON d√©cod√© avec succ√®s: $jsonResponse');

          // G√©rer la structure LoginResponse du backend
          Map<String, dynamic> responseData;
          if (jsonResponse['success'] != null) {
            // Structure ApiResponse
            responseData = jsonResponse['data'] ?? jsonResponse;
            print('üìä Structure ApiResponse d√©tect√©e');
          } else {
            // Structure directe LoginResponse
            responseData = jsonResponse;
            print('üìä Structure LoginResponse directe d√©tect√©e');
          }

          // Extraire les champs selon LoginResponse
          final token = responseData['token'];
          final expiresIn = responseData['expiresIn'];
          final trackingId = responseData['trackingId'];
          final nom = responseData['nom'];
          final prenom = responseData['prenom'];
          final email = responseData['email'];
          final numero = responseData['numero'];
          final role = responseData['role'];
          final adresse = responseData['adresse'];
          final cni = responseData['cni'];
          final dateNaissance = responseData['dateNaissance'];

          if (token != null) {
            print('üîë Token trouv√©: ${token.substring(0, 20)}...');
            print('üë§ R√¥le d√©tect√©: $role');
            print('üìß Email: $email');

            // Sauvegarder le token
            await saveToken(token);

            // Cr√©er les donn√©es utilisateur compl√®tes selon LoginResponse
            Map<String, dynamic> completeUserData = {
              'token': token,
              'expiresIn': expiresIn,
              'trackingId': trackingId,
              'nom': nom ?? '',
              'prenom': prenom ?? '',
              'email': email ?? '',
              'numero': numero ?? 0,
              'role': role ?? '',
              'adresse': adresse ?? '',
              'cni': cni ?? '',
              'dateNaissance': dateNaissance ?? '',
            };

            // Sauvegarder les donn√©es utilisateur compl√®tes
            await saveUserData(completeUserData);
            print('üë§ Donn√©es utilisateur compl√®tes sauvegard√©es');

            return {
              'success': true,
              'token': token,
              'expiresIn': expiresIn,
              'trackingId': trackingId,
              'nom': nom,
              'prenom': prenom,
              'email': email,
              'numero': numero,
              'role': role,
              'adresse': adresse,
              'cni': cni,
              'dateNaissance': dateNaissance,
              'data': completeUserData,
            };
          } else {
            print('‚ùå Token non trouv√© dans la r√©ponse');
            return {
              'success': false,
              'message': 'Token non trouv√© dans la r√©ponse du serveur',
            };
          }
        } catch (jsonError) {
          print('‚ùå Erreur de d√©codage JSON: $jsonError');
          print('üìÑ Contenu de la r√©ponse: ${response.body}');
          return {
            'success': false,
            'message': 'R√©ponse du serveur malform√©e: $jsonError',
          };
        }
      } else {
        print('‚ùå Erreur HTTP: ${response.statusCode}');

        // Gestion am√©lior√©e des erreurs avec messages UX
        try {
          if (response.body.isNotEmpty) {
            final errorResponse = json.decode(response.body);
            String userMessage = _getUserFriendlyErrorMessage(
              response.statusCode,
              errorResponse['message'],
            );
            return {
              'success': false,
              'message': userMessage,
              'errorCode': response.statusCode,
            };
          } else {
            return {
              'success': false,
              'message': _getUserFriendlyErrorMessage(response.statusCode, null),
              'errorCode': response.statusCode,
            };
          }
        } catch (e) {
          return {
            'success': false,
            'message': _getUserFriendlyErrorMessage(response.statusCode, null),
            'errorCode': response.statusCode,
          };
        }
      }
    } catch (e) {
      print('‚ùå Exception lors de la connexion: $e');
      return {'success': false, 'message': 'Erreur de connexion: $e'};
    }
  }

  // Inscription
  static Future<Map<String, dynamic>> register({
    required String nom,
    required String prenom,
    required String cni,
    required String dateNaissance,
    required String email,
    required String motDePasse,
    required int numero,
    required String adresse,
    required String role,
  }) async {
    try {
      print('üìù Tentative d\'inscription pour: $email');
      print('üåê URL: $baseUrl/register');

      final requestBody = {
        'nom': nom,
        'prenom': prenom,
        'cni': cni,
        'dateNaissance': dateNaissance,
        'email': email,
        'motDePasse': motDePasse,
        'numero': numero,
        'adresse': adresse,
        'role': role,
      };

      print('üì§ Corps de la requ√™te: $requestBody');

      final response = await http.post(
        Uri.parse('$baseUrl/register'),
        headers: {'Content-Type': 'application/json; charset=UTF-8'},
        body: jsonEncode(requestBody),
      );

      print('üì° Status Code: ${response.statusCode}');
      print('üìÑ Response Body: ${response.body}');

      if (response.statusCode == 200) {
        // V√©rifier si la r√©ponse est vide
        if (response.body.isEmpty) {
          print('‚ùå R√©ponse vide du serveur');
          return {
            'success': false,
            'message':
                'R√©ponse vide du serveur. V√©rifiez la configuration de l\'API.',
          };
        }

        try {
          final jsonResponse = json.decode(response.body);
          print('‚úÖ JSON d√©cod√© avec succ√®s: $jsonResponse');

          // G√©rer la structure RegisterResponse du backend
          Map<String, dynamic> responseData;
          if (jsonResponse['success'] != null) {
            // Structure ApiResponse
            responseData = jsonResponse['data'] ?? jsonResponse;
            print('üìä Structure ApiResponse d√©tect√©e');
          } else {
            // Structure directe RegisterResponse
            responseData = jsonResponse;
            print('üìä Structure RegisterResponse directe d√©tect√©e');
          }

          // Extraire les champs selon RegisterResponse
          final trackingId = responseData['trackingId'];
          final nom = responseData['nom'];
          final prenom = responseData['prenom'];
          final cni = responseData['cni'];
          final dateNaissance = responseData['dateNaissance'];
          final email = responseData['email'];
          final numero = responseData['numero'];
          final adresse = responseData['adresse'];
          final role = responseData['role'];

          return {
            'success': true,
            'trackingId': trackingId,
            'nom': nom,
            'prenom': prenom,
            'cni': cni,
            'dateNaissance': dateNaissance,
            'email': email,
            'numero': numero,
            'adresse': adresse,
            'role': role,
            'data': responseData,
          };
        } catch (jsonError) {
          print('‚ùå Erreur de d√©codage JSON: $jsonError');
          print('üìÑ Contenu de la r√©ponse: ${response.body}');
          return {
            'success': false,
            'message': 'R√©ponse du serveur malform√©e: $jsonError',
          };
        }
      } else {
        print('‚ùå Erreur HTTP: ${response.statusCode}');

        // Gestion am√©lior√©e des erreurs avec messages UX
        try {
          if (response.body.isNotEmpty) {
            final errorResponse = json.decode(response.body);
            String userMessage = _getUserFriendlyErrorMessage(
              response.statusCode,
              errorResponse['message'],
              isRegister: true,
            );
            return {
              'success': false,
              'message': userMessage,
              'errorCode': response.statusCode,
            };
          } else {
            return {
              'success': false,
              'message': _getUserFriendlyErrorMessage(
                response.statusCode,
                null,
                isRegister: true,
              ),
              'errorCode': response.statusCode,
            };
          }
        } catch (e) {
          return {
            'success': false,
            'message': _getUserFriendlyErrorMessage(
              response.statusCode,
              null,
              isRegister: true,
            ),
            'errorCode': response.statusCode,
          };
        }
      }
    } catch (e) {
      print('‚ùå Exception lors de l\'inscription: $e');
      return {'success': false, 'message': 'Erreur lors de l\'inscription: $e'};
    }
  }

  // Sauvegarder le token JWT
  static Future<void> saveToken(String token) async {
    try {
      final prefs = await SharedPreferences.getInstance();
      await prefs.setString(_tokenKey, token);
      print('üíæ Token sauvegard√© avec succ√®s');
    } catch (e) {
      print('‚ùå Erreur lors de la sauvegarde du token: $e');
    }
  }

  // R√©cup√©rer le token JWT
  static Future<String?> getToken() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final token = prefs.getString(_tokenKey);
      if (token != null) {
        print('üîë Token r√©cup√©r√©: ${token.substring(0, 20)}...');
      } else {
        print('üîë Aucun token trouv√©');
      }
      return token;
    } catch (e) {
      print('‚ùå Erreur lors de la r√©cup√©ration du token: $e');
      return null;
    }
  }

  // V√©rifier si l'utilisateur est connect√©
  static Future<bool> isLoggedIn() async {
    final token = await getToken();
    return token != null;
  }

  // D√©connexion
  static Future<void> signOut() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      await prefs.remove(_tokenKey);
      await prefs.remove(_userKey);
      print('üö™ D√©connexion effectu√©e');
    } catch (e) {
      print('‚ùå Erreur lors de la d√©connexion: $e');
    }
  }

  // Supprimer le token
  static Future<void> clearToken() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      await prefs.remove(_tokenKey);
      print('üóëÔ∏è Token supprim√©');
    } catch (e) {
      print('‚ùå Erreur lors de la suppression du token: $e');
    }
  }

  // Sauvegarder les donn√©es utilisateur
  static Future<void> saveUserData(Map<String, dynamic> userData) async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setString(_userKey, jsonEncode(userData));
    print('üíæ Donn√©es utilisateur sauvegard√©es: ${userData.keys}');
  }

  // R√©cup√©rer les informations compl√®tes du profil depuis le JWT
  static Future<Map<String, dynamic>> getCompleteUserData(
    String token,
    Map<String, dynamic> responseData,
  ) async {
    try {
      // D√©coder le JWT pour extraire les informations
      final parts = token.split('.');
      if (parts.length != 3) {
        print('‚ùå Token JWT invalide');
        return responseData;
      }

      // D√©coder le payload (partie 2)
      final payload = parts[1];
      final normalized = base64Url.normalize(payload);
      final resp = utf8.decode(base64Url.decode(normalized));
      final payloadMap = json.decode(resp);

      print('üîç Payload JWT d√©cod√©: $payloadMap');

      // Cr√©er un objet utilisateur complet avec toutes les informations
      Map<String, dynamic> completeUserData = {
        'token': token,
        'expiresIn': responseData['expiresIn'],
        'role': payloadMap['role'] ?? responseData['role'],
        'trackingId': payloadMap['trackingId'],
        'nom': payloadMap['nom'] ?? '',
        'prenom': payloadMap['prenom'] ?? '',
        'email': payloadMap['sub'] ?? '', // Le subject du JWT est l'email
        'cni': payloadMap['cni'] ?? '',
        'numero': payloadMap['numero'] ?? 0,
        'adresse': payloadMap['adresse'] ?? '',
        'dateNaissance': payloadMap['dateNaissance'] ?? '',
        'photoProfil': payloadMap['photoProfil'],
      };

      print(
        '‚úÖ Donn√©es utilisateur compl√®tes extraites: ${completeUserData.keys}',
      );
      return completeUserData;
    } catch (e) {
      print('‚ùå Erreur lors de l\'extraction des donn√©es JWT: $e');
      // Retourner les donn√©es de base en cas d'erreur
      return {
        'token': token,
        'expiresIn': responseData['expiresIn'],
        'role': responseData['role'],
        'email': responseData['email'] ?? '',
      };
    }
  }

  // R√©cup√©rer les donn√©es utilisateur
  static Future<Map<String, dynamic>?> getUserData() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final userDataString = prefs.getString(_userKey);
      if (userDataString != null) {
        final userData = jsonDecode(userDataString);
        print('üë§ Donn√©es utilisateur r√©cup√©r√©es');
        return userData;
      }
      print('üë§ Aucune donn√©e utilisateur trouv√©e');
      return null;
    } catch (e) {
      print('‚ùå Erreur lors de la r√©cup√©ration des donn√©es utilisateur: $e');
      return null;
    }
  }

  static Future<void> logout() async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.remove('jwt_token');
  }

  // R√©cup√©rer les informations compl√®tes de l'utilisateur connect√©
  static Future<Map<String, dynamic>?> getCurrentUserInfo() async {
    try {
      final token = await getToken();
      if (token == null) {
        print('‚ùå Aucun token trouv√©');
        return null;
      }

      print('üîç Tentative de r√©cup√©ration des infos utilisateur...');
      print('üåê URL: $baseUrl/me');

      final response = await http.get(
        Uri.parse('$baseUrl/me'),
        headers: {
          'Authorization': 'Bearer $token',
          'Content-Type': 'application/json',
        },
      );

      print('üì° Status Code: ${response.statusCode}');
      print('üìÑ Response Body: ${response.body}');

      if (response.statusCode == 200) {
        if (response.body.isEmpty) {
          print('‚ùå R√©ponse vide du serveur');
          return null;
        }

        try {
          final userData = json.decode(response.body);
          print('üë§ Informations utilisateur r√©cup√©r√©es: $userData');

          // Mettre √† jour les donn√©es utilisateur sauvegard√©es
          await saveUserData(userData);

          return userData;
        } catch (e) {
          print('‚ùå Erreur de d√©codage JSON: $e');
          print('üìÑ Contenu de la r√©ponse: ${response.body}');

          // Essayer de nettoyer la r√©ponse si elle est tronqu√©e
          if (response.body.contains('...')) {
            print(
              '‚ö†Ô∏è R√©ponse JSON tronqu√©e d√©tect√©e, utilisation des donn√©es de base',
            );
            return await getUserData();
          }

          return null;
        }
      } else {
        print(
          '‚ùå Erreur lors de la r√©cup√©ration des informations utilisateur: ${response.statusCode}',
        );
        print('üìÑ R√©ponse d\'erreur: ${response.body}');
        return null;
      }
    } catch (e) {
      print(
        '‚ùå Exception lors de la r√©cup√©ration des informations utilisateur: $e',
      );
      return null;
    }
  }

  // R√©cup√©rer les infos compl√®tes de l'ouvrier connect√©
  static Future<Map<String, dynamic>?> getCurrentOuvrierInfo() async {
    try {
      final token = await getToken();
      if (token == null) {
        print('‚ùå Aucun token trouv√©');
        return null;
      }

      print('üîç Tentative de r√©cup√©ration des infos ouvrier...');
      print('üåê URL: $baseUrl/me/ouvrier');

      final response = await http.get(
        Uri.parse('$baseUrl/me/ouvrier'),
        headers: {
          'Authorization': 'Bearer $token',
          'Content-Type': 'application/json',
        },
      );

      print('üì° Status Code: ${response.statusCode}');
      print('üìÑ Response Body: ${response.body}');

      if (response.statusCode == 200) {
        if (response.body.isEmpty) {
          print('‚ùå R√©ponse vide du serveur');
          return null;
        }

        try {
          final userData = json.decode(response.body);
          print('üë∑ Infos ouvrier r√©cup√©r√©es: $userData');

          // Mettre √† jour les donn√©es utilisateur sauvegard√©es
          await saveUserData(userData);

          return userData;
        } catch (e) {
          print('‚ùå Erreur de d√©codage JSON: $e');
          print('üìÑ Contenu de la r√©ponse: ${response.body}');

          // Essayer de nettoyer la r√©ponse si elle est tronqu√©e
          if (response.body.contains('...')) {
            print(
              '‚ö†Ô∏è R√©ponse JSON tronqu√©e d√©tect√©e, utilisation des donn√©es de base',
            );
            return await getUserData();
          }

          return null;
        }
      } else {
        print(
          '‚ùå Erreur lors de la r√©cup√©ration des infos ouvrier: ${response.statusCode}',
        );
        print('üìÑ R√©ponse d\'erreur: ${response.body}');

        // Essayer l'endpoint /me comme fallback
        print('üîÑ Tentative avec l\'endpoint /me comme fallback...');
        return await getCurrentUserInfo();
      }
    } catch (e) {
      print('‚ùå Exception lors de la r√©cup√©ration des infos ouvrier: $e');
      // Essayer l'endpoint /me comme fallback
      print('üîÑ Tentative avec l\'endpoint /me comme fallback...');
      return await getCurrentUserInfo();
    }
  }

  // Nettoyer toutes les donn√©es d'authentification
  static Future<void> clearAllAuthData() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      await prefs.remove(_tokenKey);
      await prefs.remove(_userKey);
      print('üóëÔ∏è Toutes les donn√©es d\'authentification supprim√©es');
    } catch (e) {
      print(
        '‚ùå Erreur lors de la suppression des donn√©es d\'authentification: $e',
      );
    }
  }

  // V√©rifier la validit√© du token
  static Future<bool> isTokenValid() async {
    try {
      final token = await getToken();
      if (token == null) {
        return false;
      }

      // Tenter de r√©cup√©rer les informations utilisateur pour v√©rifier la validit√©
      final userInfo = await getCurrentUserInfo();
      return userInfo != null;
    } catch (e) {
      print('‚ùå Token invalide: $e');
      // Nettoyer les donn√©es d'authentification en cas d'erreur
      await clearAllAuthData();
      return false;
    }
  }

  // D√©connexion compl√®te avec nettoyage
  static Future<void> forceLogout() async {
    try {
      await clearAllAuthData();
      print('üö™ D√©connexion forc√©e effectu√©e');
    } catch (e) {
      print('‚ùå Erreur lors de la d√©connexion forc√©e: $e');
    }
  }

  // M√©thode pour g√©n√©rer des messages d'erreur conviviaux
  static String _getUserFriendlyErrorMessage(
    int statusCode,
    String? serverMessage, {
    bool isRegister = false,
  }) {
    // Messages sp√©cifiques du serveur
    if (serverMessage != null) {
      if (serverMessage.contains('email') && serverMessage.contains('existe')) {
        return isRegister
            ? 'Cette adresse email est d√©j√† utilis√©e. Veuillez en choisir une autre.'
            : 'Aucun compte trouv√© avec cette adresse email.';
      }
      if (serverMessage.contains('mot de passe') || serverMessage.contains('password')) {
        return 'Mot de passe incorrect. Veuillez r√©essayer.';
      }
      if (serverMessage.contains('CNI') && serverMessage.contains('existe')) {
        return 'Ce num√©ro de CNI est d√©j√† enregistr√©.';
      }
      if (serverMessage.contains('validation') || serverMessage.contains('invalide')) {
        return 'Les informations saisies ne sont pas valides. V√©rifiez vos donn√©es.';
      }
    }

    // Messages g√©n√©riques selon le code de statut
    switch (statusCode) {
      case 400:
        return isRegister
            ? 'Les informations saisies ne sont pas valides. V√©rifiez tous les champs.'
            : 'Email ou mot de passe incorrect.';
      case 401:
        return 'Email ou mot de passe incorrect.';
      case 403:
        return 'Acc√®s refus√©. V√©rifiez vos permissions.';
      case 404:
        return isRegister
            ? 'Service d\'inscription non disponible.'
            : 'Service de connexion non disponible.';
      case 409:
        return 'Un compte existe d√©j√† avec ces informations.';
      case 422:
        return 'Les donn√©es fournies ne sont pas valides.';
      case 429:
        return 'Trop de tentatives. Veuillez patienter avant de r√©essayer.';
      case 500:
        return 'Erreur du serveur. Veuillez r√©essayer plus tard.';
      case 503:
        return 'Service temporairement indisponible. R√©essayez dans quelques minutes.';
      default:
        return isRegister
            ? 'Erreur lors de l\'inscription. Veuillez r√©essayer.'
            : 'Erreur de connexion. V√©rifiez votre connexion internet.';
    }
  }
}
